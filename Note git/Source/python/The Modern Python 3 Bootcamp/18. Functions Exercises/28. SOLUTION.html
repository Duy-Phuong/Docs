<h4>"Traditional"&nbsp;Version</h4>

<p>Here's my solution that doesn't use a list comprehension:</p>

















<ul><li>I have two lists, to hold the true and false values</li><li>I loop through the list, calling <code>fn</code>&nbsp; with each value in the list</li><li>If the result is True, I&nbsp;append the value to the <code>trues</code>&nbsp; list</li><li>Otherwise, I append the value to the <code>falses</code>&nbsp; list</li><li>At the end I return a list that contains both the&nbsp;<code>trues</code>&nbsp; and <code>falses</code>&nbsp; lists</li></ul>



















<pre class="prettyprint linenums">def partition(lst, fn):
    trues = []
    falses = []
    for val in lst:
        if fn(val):
            trues.append(val)
        else:
            falses.append(val)
    return [trues, falses]</pre>





































<p><br></p>



















<h4>List Comprehension&nbsp;Version</h4>







<p>Using a list comprehension, you can get this function down to a single line.&nbsp; It's definitely a tradeoff though.&nbsp; It's much short but also more difficult to understand.&nbsp; It's a fine balance between brevity and readability.&nbsp;</p>

<pre class="prettyprint linenums">
def partition(lst, fn):
    return [[val for val in lst if fn(val)], [val for val in lst if not fn(val)]]</pre><p><br></p><h4>Another Solution</h4>

<p>This solution was submitted by a student named Jonathan.&nbsp; Thanks, Jonathan!<br></p>

<pre class="prettyprint linenums">def partition(l, callback):
    return [[l.pop(l.index(i)) for i in l if callback(i)],l]</pre>